# GOF的23种设计模式

## 一、单例模式

### 1.1 定义

一个类只有一个实例，且该类可以自行创建这个实例



### 1.2  结构

**单例模式的主要角色如下：**

1. 单例类：包含一个实例且能自行创建这个实例的类
2. 访问类：使用单例的类



## 二、工厂方法模式

### 2.1 定义

定一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到了具体子工厂类

当中。这满足了创建型模式中 **“创建与使用分离”** 的特点。



- 我们把被创建的对象成为**“产品”**，把创建产品的对象成为**工厂**。
- 如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫 **“简单工厂模式”**，它严格意义上不属于GOF的23种经典设计模式，它的缺点是增加新的产品的时候会违背 **“开闭原则”**。



这次介绍的 **“工厂方法模式”** 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，既满足 **“开闭原则”**。



### 2.2 优缺点

**优点：**

1. 用户只需要知道具体工厂的名称就可以得到所要的产品，无需知道产品的具体创建的过程。
2. 在系统增加新的产品时，只需要添加具体的产品类和对应的具体工厂类，无需对原工厂进行修改，满足 **“开闭原则”**。

**缺点：**

每增加一个产品就需要增加一个具体的产品类和一个对应的具体工厂类，增加了代码维护的复杂度。



### 2.3 结构

**工厂方法模式**由 **抽象工厂**、**具体工厂**、**抽象产品**、**具体产品**  4个要素构成

**工厂方法模式的主要角色如下：**

1.  抽象工厂（Abstract Factory） ：提供创建对象的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
2.  具体工厂（Concrete Factory） ：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3.  抽象产品（Abstract Product） ：定义了产品的规范，描述了产品的主要特性和功能。
4.  具体产品（Concrete Product） ：实现抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。



## 三、抽象工厂模式

### 3.1 定义

- 工厂方法模式考虑的是生产同等级的产品
- 产品族：位于不同等级的一组产品

**抽象工厂模式**是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同等级产品的模式结构。

**抽象工厂模式**是**工厂方法模式**的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。



### 3.2 优缺点

**优点：**

1. 具备工厂方法模式的优点
2. 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必引入多个新的类来进行管理。
3. 当增加一个新的产品族时，不需要修改原代码，满足 **"开闭原则"**。

**缺点：**

当产品族中需要增加一个新的产品时，所有的工厂类都需要修改



### 3.3 结构

抽象工厂模式和工厂方法模式一样，也是由 **抽象工厂**、**具体工厂**、**抽象产品**、**具体产品** 4个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。

**抽象工厂模式的主要角色如下：**

1.  抽象工厂（Abstract Factory） ：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。
2.  具体工厂（Concrete Factory） ：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3.  抽象产品（Abstract  Product） ：定义了产品的规范，描述了产品的主要特性和性能，抽象工厂模式有多个抽象产品。
4.  具体产品（Concrete Product） ：实现抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是 **多对一** 的关系。



## 四、建造者模式

 在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。 

### 4.1 定义

将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式称为 “建造者模式”。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建完成。它将变与不变相分离，即产品的组成部分是不变的，但是每一部分是可以灵活选择的。



### 4.2 优缺点

**优点：**

1. 各个具体的建造者相互独立，有利于系统的扩展
2. 客户端不必知道产品内部组成的细节，便于控制细节风险。

**缺点：**

1. 产品的组成部分必须相同，这限制了其使用范围。
2. 如果产品内部变化复杂，该模式会增加很多的建造者类。

**注意：**建造者模式 和 工厂模式的关注点不同：建造者模式注重**零部件的组装过程**，而工厂方法模式更注重**零部件的创建过程**，二者可以结合使用。



### 4.3 结构

建造者模式由**产品**、**抽象建造者、具体建造者**、**指挥者** 4个要素构成

**建造者模式的主要角色如下：**

1.  产品角色（Abstract Product） ：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
2.  抽象建造者（Builder） ：它是一个包含创建产品各个零部件的抽象方法的接口，通常还包括一个返回复杂产品的方法。
3.  具体建造者(Concrete Builder） ：实现builder接口，完成复杂产品各个部件的具体创建方法。
4.  指挥者（Director） ：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。



## 五、原型模式

### 5.1 定义

1. 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同或相似的新对象。
2. 在这里，原型实例指定了要创建对象的种类，用这种方式创建对象非常高效，根本无需知道创建对象的细节。



### 5.2 优缺点

1. 效率高（直接克隆，避免了重复执行构造方法）
2. 克隆类似于new，但又不同于new，new创建的对象属性采用默认值，克隆出来的对象的属性和原型对象完全相同，并且克隆出来的新对象的改变不会影响原型对象。



### 5.3 结构

由于java 提供了对象的clone()方法，所以用java实现原型模式很简单。

**原型模式主要角色包含：**

1. 抽象原型类：规定了具体原型对象必须实现的接口。
2. 具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。
3. 访问类：使用具体原型类中的clone()方法来复制新的对象。



## 六、适配器模式

### 6.1 定义

1.  将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 
2. 适配器模式分为类结构型模式和对象结构型模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少。

### 6.2 优缺点

**优点：**

1. 客户端通过适配器可以透明的调用目标接口。
2. 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
3. 将目标类和适配者类解耦，解决了目标类和适配者类不一致的问题。

**缺点：**

对类适配器来说，更换适配器类的实现过程比较复杂。



### 6.3 结构

 类适配器模式可采用多重继承方式实现，如 [C++](http://c.biancheng.net/cplus/) 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；[Java](http://c.biancheng.net/java/) 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 

对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。

**适配器模式包含以下主要角色：**

1.  目标（Target）接口： 当前系统业务所期待的接口，它可以是抽象类或接口。
2.  适配者（Adaptee）类 ：它是被访问和适配的现存组件库中的组件接口。
3.  适配器（Adapter）类 ：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按照目标接口的格式访问适配者。



## 七、代理模式

 在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。 

### 7.1 定义

由于某些原因需要给某对象提供一个代理以控制该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。



### 7.2 优缺点

**优点：**

1. 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。
2. 代理对象可以扩展目标对象的功能。
3. 代理模式可以将代理对象和目标对象分离，在一定程度上降低了系统的耦合度。

**缺点：**

1. 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。
2. 增加了系统的复杂度。



### 7,3 结构

 代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。 

**代理模式主要角色如下：**

1.  抽象主题（Subject）类 ：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
2.  真实主题（Real Subject）类 ：实现抽象主题类中的具体业务，是代理对象所代表的的真实对象，是最终要引用的对象。
3.  代理（Proxy）类 ：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制、扩展真实主题的功能。



## 八、桥接模式

 在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photo shop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。 

### 8.1 定义

 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 



### 8.2 优缺点

**优点：**

1.  由于抽象与实现分离，所以扩展能力强；。
2.  其实现细节对客户透明。 

**缺点：**

 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 



### 8.3 结构

 可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。 

**桥接（Bridge）模式包含以下主要角色：**

1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
2. 扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。